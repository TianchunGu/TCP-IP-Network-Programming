# ch04 基于TCP的服务器端/客户端

第四章的核心主题是**“基于TCP的服务器端与客户端的实现”**。

## 1. 理解TCP和UDP

理解 TCP 套接字在整个网络通信中的位置：

+ 分层的意义：将庞大的网络通信问题划分为小问题逐个解决。
+ 链路层与 IP 层：IP 层负责在复杂的网络中寻找路径，但它是不可靠的，数据可能会丢失或顺序错乱。
+ TCP 层的作用：TCP 建立在 IP 层之上，它通过确认机制（ACK）和重传机制，为不可靠的 IP 传输添加了可靠性，确保数据按序到达且不丢失。
+ 应用层：这就是我们要编写的程序，根据程序特点制定数据传输规则（协议）。

![cs](./img/TCPIP协议栈.jpg "TCP/IP协议栈")

## 2. 实现基于TCP的服务器端和客户端（被动连接）

### *1. TCP服务器端的默认函数调用顺序*

> 服务器端的核心任务是“等待并接受连接”，绝大部分 TCP 服务器端都按照该顺序调用：

1. `socket` 创建套接字
2. `bind` 分配套接字地址
3. `listen` 等待连接请求状态
4. `accept` 允许连接
5. `read/write` 数据交换
6. `close` 断开连接

### *2. 进入等待请求连接状态*

我们已经调用 `bind` 函数给套接字分配了地址，接下来就要通过调用 `listen` 函数进入等待连接请求状态。只有调用了 `listen` 函数，客户端才能进入可发出连接请求的状态。换言之，这时客户端才能调用 `connect` 函数（若提前调用将发生错误）。

```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
int listen(int sockfd, int backlog);
// 成功时返回0，失败时返回-1
// 详见手册
```

+ *sockfd* 为希望进入等待连接请求状态的套接字文件描述符，传递的描述符套接字参数成为服务器端套接字（监听套接字）。
+ *backlog* 连接请求等待队列的长度，若为5，则队列长度为5，表示最多使5个连接请求进入队列。

listen 函数的第二个参数值与服务器端的特性有关，像频繁接收请求的 Web服务器端至少应为15。另外，连接请求队列的大小始终根据实验结果而定。

服务器端处于等待连接请求状态是指，客户端请求连接时，受理连接前一直使请求处于等待状态 。

### *3. 受理客户端连接请求*

```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

+ *sock* 服务器端套接字的文件描述符，
+ *addr* 保存发起连接请求的客户端地址信息的变量地址值，调用函数后向传递来的地址变量参数填充客户端地址信息。
+ *addrlen* 第二个参数 *addr* 结构体的长度，但是存有长度的变量地址值。函数调用完成后，该变量即被填入客户端地址长度。

`accept` 函数受理连接请求等待队列中待处理的客户端连接请求。函数调用成功时，`accept` 函数内部将产生用于数据I/O的套接字，并返回其文件描述符。需要强调的是，套接字是自动创建的，并自动与发起连接请求的客户端建立连接。

回顾 Hello World服务器端：
[hello_server.c](../ch01-理解网络编程和套接字/hello_server.c)

### *4. TCP客户端的默认函数调用顺序（主动连接）*

1. `socket` 创建套接字
2. `connect` 请求连接
3. `read/write` 交换数据
4. `close` 断开连接

与服务器端相比，区别就在于 "请求连接"，它是创建客户端套接字后向服务器端发起的连接请求。服务器端调用 `listen` 函数后创建连接请求队列，之后客户端即可请求连接。

```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
int connect(int sockfd, const struct sockaddr *addr,
                socklen_t addrlen);
// 成功时返回0，失败时返回-1
// 详见手册
```

+ *sock* 客户端套接字文件描述符，
+ *servaddr* 保存目标服务器地址信息的变量地址值，
+ *addrlen* 以字节为单位传递第二个结构体参数
+ *servaddr* 的地址变量长度。  

客户端调用 `connect` 函数后，发生以下情况之一才会返回（完成函数调用）。

+ 服务器端接收连接请求。
+ 发生断网等异常情况而中断连接请求。

需要注意，所谓的 "接收连接" 并不意味着服务器端调用 `accept` 函数，其实是服务器端把连接请求信息记录到等待队列。因此，`connect` 函数返回后并不立即进行数据交换。

> **知识补给站：** 客户端套接字何时、何地、如何分配地址呢？

+ 何时？ 调用 `connect` 函数时
+ 何地？ 操作系统内核
+ 如何？ IP用计算机（主机）的IP，端口随机

客户端的IP地址和端口号在调用 `connect` 函数时自动分配，无需调用标记的 `bind` 函数进行分配。

回顾Hello World客户端：[hello_client.c](../ch01-理解网络编程和套接字/hello_client.c)

![cs](./img/ch04.png "函数调用关系")

服务器端创建套接字后连续调用 `bind`、`listen` 函数进入等待状态，客户端通过调用 `connect` 函数发起连接请求。需要注意的是，客户端只能等到服务器端调用 `listen` 后才能调用 `connect` 函数。同时要清楚，客户端调用 `connect` 函数前，服务器端有可能率先调用 `accept` 函数，当然，此时服务器端在调用 `accept` 函数时进入阻塞状态，直到客户端调用 `connect` 函数为止。

## 3. 实现迭代服务器端/客户端

本节编写回声（echo）服务器端/客户端。
服务器端将客户端传输的字符串数据原封不动地传回客户端，就像回声一样。

### *1. 迭代回声服务器端/客户端*

基本运作方式如下：

+ 服务器端在同一时刻只与一个客户端相连，并提供回声服务。
+ 服务器端依次向5个客户端提供服务并退出。
+ 客户端接收用户输入的字符串并发送到服务器端。
+ 服务器端将接收到的字符串数据传回客户端，即回声。
+ 客户端输入q退出。

[echo_server.c](./echo_server.c)
[echo_client.c](./echo_client.c)

+ 迭代服务器（Iterative Server）：
  + 通过在 accept 外层包裹一个 while 循环，服务器可以一个接一个地服务多个客户端。
  + 局限性：同一时刻只能服务一个客户端。如果一个客户端占用时间过长，后续客户端必须在队列中等待。

### *2. 回声客户端存在的问题（TCP不存在数据边界）*

```c
write(sock, message, strlen(message));
str_len = read(sock, message, BUF_SIZE);
```

以上代码有个错误假设，"每次调用 `read`、`write` 函数时都会以字符串为单位执行实际的I/O操作"。当然，每次调用 `write` 函数都会传递一个字符串，因此这种假设在某种程度上也算合理。但是 "TCP不存在数据边界"（[参见第二章](../ch02-套接字类型与协议设置/README.md#3-tcp套接字示例)）。上述客户端是基于TCP的，因此，多次调用 `write` 函数传递的字符串有可能一次性传递到服务器端。此时客户端客户端有可能从服务器端收到多个字符串，这不是我们希望看到的结果。还需考虑服务器端的以下情况："字符串太长，需要分2个数据包发送"。服务器端希望通过一次 `write` 函数调用传输数据，但如果数据太大，操作系统有可能把数据分成多个数据包发送到客户端。另外，在此过程中，客户端有可能在尚未收到全部数据包时就调用 `read` 函数。所有的这些问题都源自TCP的数据传输特性。那该如何解决呢？[参见第5章](../ch05-基于TCP的服务器端和客户端_2/READMD.md)。

---

#### 详细理解错误假设

##### 1. 错误的假设：认为“一次发送 = 一次接收”

+ 在代码编写中，程序员往往习惯认为：我调用了一次 write 发送了 "Hello"，对方就应该通过一次 read 收到 "Hello"。
+ 书中的错误假设：回声客户端的代码逻辑是 write 发送数据后，紧接着调用一次 read 来接收回声。它默认服务器端会原样、完整、一次性地把发过去的数据发回来，而且客户端能一次性读完。
+ 现实情况：这种假设在数据量小、网络环境极其简单（如本机 localhost 测试）时往往能碰巧成功，但这纯属“运气”。

##### 2. 核心原理：TCP 不存在数据边界

这段话引用的核心理论来自书中第二章：TCP 是面向连接的套接字，传输的数据不存在数据边界。

+ 传送带比喻：书中将 TCP 传输比喻为“传送带”。你在传送带这头放下一个包裹（write），又放下一个包裹。在传送带那头（接收端），这两个包裹可能会紧挨着到达，接收者可能一次性把两个都拿起来（一次 read 读取所有数据），也可能分多次拿。
+ 字节流：TCP 套接字内部有缓冲区（字节数组）。数据发出去后，操作系统不保证它是作为一个独立的“包”到达对方，而是像水流一样流入对方的缓冲区。

##### 3. 具体会发生什么问题？

这段话中描述了两种典型的由“无边界”特性引发的问题：

+ 情况 A：粘包（多次 write，一次 read）
  + 场景：客户端连续调用多次 write 发送字符串。
  + 结果：因为 TCP 传输快，这几个字符串可能积攒在发送缓冲区，被操作系统打包成一个大数据包发过去；或者在接收端的缓冲区里堆积在了一起。
  + 后果：客户端调用一次 read，可能一下子读到了服务器发回来的多个字符串拼接在一起的内容，这与客户端“发一个收一个”的逻辑不符。
+ 情况 B：拆包（一次 write，多次 read）
  + 场景：服务器端回传的字符串太长（例如超过了最大传输单元 MTU，或者接收端缓冲区较小）。
  + 结果：操作系统会将这个长数据拆分成多个数据包发送。
  + 后果：客户端调用一次 read，可能只读到了字符串的前半部分。代码如果没有循环读取的逻辑，就会处理错误的不完整数据。

##### 4. 如何解决？（第五章的预告）

+ 解决方案：书中第五章给出了解决方法，即提前告知数据长度或定义边界。
+ 示例：在 echo_client2.c 中，因为我们知道发送了多少字节（str_len），所以在接收时，可以通过循环调用 read，直到累计接收到的字节数等于发送的字节数为止,。
