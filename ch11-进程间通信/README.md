# ch11 进程间通信

## 1. 进程间通信的基本概念

进程间通信(Inter Process Communication，IPC)意味着两个不同进程间可以交换数据，为了完成这一点，操作系统应该提供两个进程可以同时访问的内存空间。

### _1. 对进程间通信的基本理解_

进程A和B之间的如下谈话内容就是一种进程间通信规则。

“如果我有1个面包，变量 _bread_ 的值就变为1。如果吃掉这个面包，_bread_ 的值又变为0；因此，你可以通过变量 _bread_ 的值判断我的状态。”

也就是说，进程A通过变量 _bread_ 将自己的状态通知给了进程B，进程B通过变量 _bread_ 听到了进程A的话。因此，只要有两个进程可以同时访问的内存空间，就可以通过此内存空间交换数据。但正如第10章所讲，进程具有完全独立的内存结构。就连通过 `fork` 函数创建的子进程也不会与父进程共享内存空间。因此，进程间通信只能通过其他特殊方法完成。

### _2. 通过管道实现进程间通信_

下图表示基于管道的进程间通信模型。

![pipe](./pipe.png '基于管道的进程间通信模型')

从上图中可以看到，为了完成进程间通信，需要创建管道。管道并非属于进程的资源，而是和套接字一样，属于操作系统。所以两个进程通过操作系统提供的内存空间进行通信。下面介绍创建管道的函数。

```c
#include <unistd.h>
int pipe(int filedes[2]);
// 成功时返回0，失败时返回-1
```

- _filedes[0]_ ：通过管道接收数据时使用的文件描述符，即管道出口；
- _filedes[1]_ ：通过管道传输数据时使用的文件描述符，即管道入口。

> 机制：一个进程往管子一头塞数据（Write），另一个进程从管子另一头取数据（Read）。

_来个例子：_

[pipe1.c](./pipe1.c)

```bash
lxc@Lxc:~/C/tcpip_src/ch11-进程间通信$ bin/pipe1
Who are you?
```

该示例中的通信方法及路径如下图所示。

![pipe](./pipe1.png '示例pipe1.c的通信路径')

使用流程是：

1. 父进程调用 pipe 创建管道。
2. 父进程调用 fork。
3. 关键点：子进程会自动复制父进程的文件描述符。所以，父子进程现在都拥有了操作这同一个管道的入口和出口。

### _3. 通过管道进行进程间的双向通信_

下面创建2个进程通过1个管道进行双向数据交换，其通信方式如下图所示：

![pipe](./pipe2.png '双向通信模型1')

[pipe2.c](./pipe2.c)

注意第19行的 `sleep` 函数调用。**_向管道传递数据时，先读的进程会把数据取走_**。简言之，数据进入管道后成为无主数据。也就是通过 `read` 函数先读取数据的进程将得到数据，即使是该进程将数据传到了管道。所以，注释第19行将产生问题，在下一行，子进程将读回自己向管道中发送到数据。结果，父进程调用 `read` 后将无限期等待数据进入管道。

从上述示例可以看到，只用1个管道进行双向通信并非易事。为了实现这一点，程序需要预测并控制运行流程，这在每种系统中都不同，可以视为不可能完成的任务。那可咋办呢？  
非常简单，1个管道无法完成双向通信的任务，那创建2个管道，各自负责不同的数据流动即可。如下图所示。

![pipe](./pipe3.png '双向通信模型2')

- 解决方案：创建两个管道。
  - 管道 1：父进程写 -> 子进程读。
  - 管道 2：子进程写 -> 父进程读。
  - 这样各自负责不同的数据流向，互不干扰。

[pipe3.c](./pipe3.c)

## 2. 运用进程间通信

### _1. 保存消息的回声服务器端_

下面扩展第10章的 _echo_mpserv.c_，添加如下功能：将回声客户端传输的字符串按序保存到文件中。

[echo_storeserv.c](./echo_storeserv.c)。该示例可与任意回声客户端配合运行，我们用第10章的 [_echo_mpclient.c_](./echo_mpclient.c) 。

## 3. 关于进程间通信的更多资料

[进程间通信的更多资料](https://www.yuque.com/tianchungu/ncu2bb/yhh4bhwtq9gcee1u#vBnh7)
